# Challenge: Task Manager API

REST API for managing tasks and users, built with NestJS and in-memory storage.

---

## How to run

```bash
# 1. Install dependencies
npm install

# 2. Start in development mode
npm run start:dev
```

The API is available at `http://localhost:3000`.
Swagger documentation at `http://localhost:3000/docs`.

The app starts with pre-loaded data (3 users and 6 tasks) to allow immediate testing of the endpoints.

---

## Design

```
src/
├── common/
│   ├── types/timestamps.ts        # Base class with createdAt, updatedAt, deletedAt
│   └── seed/seed-data.ts          # Initial data separated from business logic
├── modules/
│   ├── users/                     # Users module (Full CRUD)
│   │   ├── dto/                   # Input validation (class-validator)
│   │   ├── entities/              # User entity definition
│   │   ├── users.repository.ts    # Data access (in-memory)
│   │   ├── users.service.ts       # Business logic
│   │   └── users.controller.ts    # REST endpoints
│   └── task/                      # Task module (CRUD + filters + status change)
│       ├── dto/
│       ├── entities/
│       ├── types/                 # Enums: TaskStatus, TaskPriority, TaskSortableField
│       ├── task.repository.ts
│       ├── task.service.ts
│       └── task.controller.ts
└── main.ts                        # Bootstrap + Swagger + ValidationPipe
```

**Repository Pattern:** Each module has its own repository that encapsulates data access. The service never accesses the array directly, always through the repository. This means that if a real database is connected in the future, only the repository needs to change without touching the service or controller.

**Module Relationships:** `TaskModule` imports `UsersModule` to share the same `UserRepository` instance. This ensures that when a new user is created, it is immediately available to be assigned to tasks.

**Seed data:** Initial data lives in a separate file (`seed-data.ts`) and is loaded via `OnModuleInit` in each repository. This keeps repositories clean and test data centralized.

**Soft delete:** Records are not physically deleted; they are marked with `isDeleted: true` and `deletedAt`. All queries automatically filter out deleted records.

---

## Tradeoffs and assumptions

- **In-memory storage:** Data does not persist between restarts. This was an intentional decision to keep the project free of external dependencies (databases, Docker, etc.) and make it easy to run with a single `npm run start:dev`.

- **Auto-incrementing string IDs:** `(array.length + 1).toString()` is used to generate IDs. It is simple but not production-safe (if a record is deleted and another created, they could collide). In a real project, UUIDs would be used.

- **No authentication:** Auth was not implemented as it was not part of the scope. The module structure allows adding it easily as a global guard.

- **Sorting Enums:** `TaskSortableField` was created as an enum that only includes fields that can actually be sorted, instead of exposing all entity fields (like `assignee` or `comments` which don't make sense for sorting).

- **`status` as query param in findAll:** Renamed from `estado` to `status` to maintain English consistency throughout the API.

---

## What I would improve with more time

- **Real Persistence:** Connect PostgreSQL with Prisma or TypeORM, replacing in-memory repositories.
- **Pagination:** Add `take` and `page` to list endpoints to handle large volumes of data.
- **Response DTOs:** Create separate response DTOs to control exactly which fields are returned to the client (instead of returning the entity directly).
- **Global Error Handling:** Implement an exception filter that standardizes the error format across the entire API.
- **Business Validations:** For example, prevent deleting a user who has active tasks assigned.

---

## How I used AI tools

I used **Claude Code** (CLI) as an assistant throughout development. Some concrete examples:

1. **Initial Scaffolding:** I asked it to analyze the project and complete the users module which was empty (it only had files generated by `nest g resource`). It generated the repository, service, and controller with the same structure as the task module, saving me time on repetitive tasks.

2. **Debugging:** When task `findAll` filtered by `assignedUserId` and only returned 1 result instead of 2, Claude identified that `TaskModule` was instantiating its own `UserRepository` instead of importing `UsersModule`, creating two separate instances of the same repository.

3. **Another subtle bug:** The `update` method in the task repository was doing `assignee: undefined` when spreading, overwriting the original assignee when `setTaskStatus` was called. Claude detected that `assignee` as an undefined parameter propagated to the object and corrected it.

4. **Documentation:** I asked it to help implement Swagger documentation applying simple examples for input and output DTOs for each endpoint.

5. **Seed data:** I asked it to generate a seed with several "real" examples relating 2 tasks per user.

6. **Readme:** I asked it to help me generate the README with the current structure to make it more understandable and readable.

Overall, Claude was useful for accelerating repetitive tasks (Swagger decorators, CRUD boilerplate) and for detecting bugs that require understanding the interaction between modules. I always reviewed the generated code before accepting it.
